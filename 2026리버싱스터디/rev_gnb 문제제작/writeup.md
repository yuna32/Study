rev_gnb 문제제작 라이트업
=============


### 1. 문제 개요

* **파일 구성:** 실행 파일 및 암호화된 데이터 파일(`secret.dat`)
* **목표:** 알 수 없는 1바이트 Key를 찾아 `secret.dat`의 내용을 복호화하고 플래그를 획득

### 2. 출제 의도

* **데이터 흐름 추적:** 외부 파일의 데이터가 메모리(Heap)에 로드되고 연산 과정을 거쳐 변화하는 과정을 동적으로 추적
* **어셈블리 루프 분석:** xor 연산이 포함된 반복문을 찾아내고 인덱스와 데이터 간의 관계를 파악
* **런타임 값 조작:** 정답을 모르는 상태에서 디버거 내에서 조작을 통해 레지스터나 메모리 값을 수정하여 프로그램의 결과를 변경

### 3. 풀이 과정

#### 단계 1: 정적 분석 및 진입점 파악

프로그램 실행 시 `secret.dat`을 읽는 것을 확인. main 함수 내에서 scanf로 키를 입력받은 직후 호출되는 decrypt_file 함수가 핵심 로직임을 파악하고 해당 지점에 브레이크포인트를 설정

#### 단계 2: 동적 분석 및 XOR 로직 확인

pwndbg를 통해 decrypt_file 내부로 진입해 어셈블리를 분석

<img width="983" height="668" alt="스크린샷 2026-02-20 222700" src="https://github.com/user-attachments/assets/5ca3f8a2-95c1-4eb3-9116-48f8dd51f2af" />


* **명령어:** xor al, BYTE PTR [rbp-0x20]
* **상태 분석:** * al 레지스터에는 파일에서 읽어온 첫 번째 바이트 값인 0x3c가 들어있음
* [rbp-0x20] 위치에는 사용자가 입력한 값(여기서는 10 → 0x0a)이 저장되어 있음


#### 단계 3: 키 역산

모든 플래그는 보통 FLAG로 시작한다는 일반적인 규칙을 활용 (실제 출제 시에는 플래그 형태 고지할 예정)

* **수식:** 암호문(0x3c) ^ Key = 평문('F' = 0x46)
* **계산:** Key = 0x3c ^ 0x46 = 0x7a (122)
이 과정을 통해 정답 키가 **0x7a** 임을 도출

#### 단계 4: 메모리 패치 및 결과 확인

디버거의 기능을 활용해 실제 입력값을 무시하고 메모리를 강제로 수정

<img width="912" height="352" alt="스크린샷 2026-02-20 222841" src="https://github.com/user-attachments/assets/d6ab6aea-c130-46d3-b038-c18a6ad4db13" />


1. **값 수정:** set {unsigned char}($rbp-0x20) = 0x7a 명령을 통해 메모리상의 키 값을 정답으로 변경
2. **연산 진행:** xor를 수행하자 rax에 0x46('F')이 저장되는 것을 확인
3. **최종 확인:** 함수를 끝까지 실행하자 메모리 버퍼에 복구된 전체 플래그가 나타남

**[획득한 플래그]**

<img width="808" height="75" alt="스크린샷 2026-02-20 222911" src="https://github.com/user-attachments/assets/c4eb18dd-584f-4b07-981c-bd380eb4caf5" />


